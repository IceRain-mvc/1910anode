(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{290:function(t,_,a){"use strict";a.r(_);var s=a(28),v=Object(s.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_1、abstract关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、abstract关键字"}},[t._v("#")]),t._v(" 1、abstract关键字")]),t._v(" "),a("ul",[a("li",[t._v("可以修饰类:"),a("code",[t._v("public abstract class Pet{}")]),t._v("  这个类称为抽象类")]),t._v(" "),a("li",[t._v("可以修饰方法:"),a("code",[t._v("public abstract void show();")]),t._v("称为抽象方法")])]),t._v(" "),a("h3",{attrs:{id:"_2、-抽象类："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、-抽象类："}},[t._v("#")]),t._v(" 2、 抽象类：")]),t._v(" "),a("ul",[a("li",[t._v("a、抽象类不能实例化(new 对象)")]),t._v(" "),a("li",[t._v("b、抽象类不一定只有抽象方法")]),t._v(" "),a("li",[t._v("c、有抽象方法的类一定是抽象类")]),t._v(" "),a("li",[t._v("d、抽象方法没有方法体")]),t._v(" "),a("li",[t._v("e、抽象类中可以有构造方法 ，如何调用构造方法：子类的构造方法中使用super()关键字调用抽象类的构造方法。")]),t._v(" "),a("li",[t._v("f、子类必须重写抽象类中所有抽象方法，除非子类也是抽象类。")])]),t._v(" "),a("h3",{attrs:{id:"_3、接口：特殊的抽象类，是一种标准，是一种规范。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、接口：特殊的抽象类，是一种标准，是一种规范。"}},[t._v("#")]),t._v(" 3、接口：特殊的抽象类，是一种标准，是一种规范。")]),t._v(" "),a("p",[t._v("语法：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyStudent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("show")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("h3",{attrs:{id:"_4、必须知道的接口的特性："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、必须知道的接口的特性："}},[t._v("#")]),t._v(" 4、必须知道的接口的特性：")]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("strong",[t._v("1、")]),t._v(" 接口不可以被实例化(原因：接口是一种特殊的抽象类)")]),t._v(" "),a("li",[a("strong",[t._v("2、")]),t._v(" 一个类可以实现多个接口，非抽象类实现接口时必须实现接口中的全部方法")]),t._v(" "),a("li",[a("strong",[t._v("3、")]),t._v(' 实现类可以实现多个接口,多个接口用","隔开      这就是java中的多继承')]),t._v(" "),a("li",[a("strong",[t._v("4、")]),t._v(" 接口中的变量都是静态常量   "),a("code",[t._v('public static final String NAME="";')]),t._v("   其中 "),a("code",[t._v("public static final")]),t._v("  可以不写")]),t._v(" "),a("li",[a("strong",[t._v("5、")]),t._v(" 接口中方法都是全局抽象方法")]),t._v(" "),a("li",[a("strong",[t._v("6、")]),t._v(" 无构造方法")])])]),t._v(" "),a("h3",{attrs:{id:"_5、使用接口的步骤："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、使用接口的步骤："}},[t._v("#")]),t._v(" 5、使用接口的步骤：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("1、")]),t._v(" 编写接口")]),t._v(" "),a("li",[a("strong",[t._v("2、")]),t._v(" 实现接口")]),t._v(" "),a("li",[a("strong",[t._v("3、")]),t._v(" 使用接口")])]),t._v(" "),a("h3",{attrs:{id:"_6、接口是一种能力"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、接口是一种能力"}},[t._v("#")]),t._v(" 6、接口是一种能力")]),t._v(" "),a("ul",[a("li",[t._v("体现在接口的方法上，（也可以说从接口的方法就能看出接口能干什么）")])]),t._v(" "),a("h3",{attrs:{id:"_7、接口是一种约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、接口是一种约定"}},[t._v("#")]),t._v(" 7、接口是一种约定")]),t._v(" "),a("ul",[a("li",[t._v("体现在接口名称和注释上（有些接口只有名称，方法的实现方式要通过注释来约定）")])]),t._v(" "),a("h3",{attrs:{id:"_8、面向接口编程的程序设计时："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8、面向接口编程的程序设计时："}},[t._v("#")]),t._v(" 8、面向接口编程的程序设计时：")]),t._v(" "),a("ul",[a("li",[t._v("关心实现类有何能力，而不关心实现细节（接口中有多少个方法）")]),t._v(" "),a("li",[t._v("面向接口的约定而不考虑接口的具体实现（每个方法名字和注释要写全了）")])]),t._v(" "),a("h3",{attrs:{id:"_9、接口比抽象类更好的特性："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9、接口比抽象类更好的特性："}},[t._v("#")]),t._v(" 9、接口比抽象类更好的特性：")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("1、")]),t._v(" 可以被多继承\n"),a("strong",[t._v("2、")]),t._v(" 设计和实现完全分离\n"),a("strong",[t._v("3、")]),t._v(" 更自然的使用多态\n"),a("strong",[t._v("4、")]),t._v(" 更容易搭建程序框架\n"),a("strong",[t._v("5、")]),t._v(" 更容易更换实现。\n"),a("strong",[t._v("6、")]),t._v(" 抽象类利于代码复用，接口利于代码维护")])]),t._v(" "),a("h3",{attrs:{id:"_10、抽象类vs接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、抽象类vs接口"}},[t._v("#")]),t._v(" 10、抽象类vs接口")]),t._v(" "),a("ul",[a("li",[t._v("相同点\n"),a("blockquote",[a("ul",[a("li",[t._v("代表系统的抽象层")]),t._v(" "),a("li",[t._v("都不能被实例化")]),t._v(" "),a("li",[t._v("都能包含抽象方法（用于描述系统提供的服务，不必提供具体实现）")])])])]),t._v(" "),a("li",[t._v("不同点\n"),a("blockquote",[a("ul",[a("li",[t._v("在抽象类中可以为部分方法提供默认实现，而接口中只能包含抽象方法（抽象类便于复用，接口便于代码维护）")]),t._v(" "),a("li",[t._v("一个类只能继承一个直接的父类，但可以实现多个接口")])])])]),t._v(" "),a("li",[t._v("使用原则\n"),a("blockquote",[a("ul",[a("li",[t._v("接口做系统与外界交互的窗口")]),t._v(" "),a("li",[t._v("接口提供服务")]),t._v(" "),a("li",[t._v("接口本身一旦制定，就不允许随意修改")]),t._v(" "),a("li",[t._v("抽象类可完成部分功能实现，还有部分功能可作为系统的扩展点")])])])])]),t._v(" "),a("h3",{attrs:{id:"_11、面向对象设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、面向对象设计原则"}},[t._v("#")]),t._v(" 11、面向对象设计原则")]),t._v(" "),a("ul",[a("li",[t._v("多用组合，少用继承")]),t._v(" "),a("li",[t._v("针对接口编程")]),t._v(" "),a("li",[t._v("针对扩展开放，针对改变关闭")])])])}),[],!1,null,null,null);_.default=v.exports}}]);